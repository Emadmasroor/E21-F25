---
---

# HW 10

* Table of Contents
{:toc}

## Summary

**Due Date**: Tuesday after Thanksgiving  
**What to submit**:
- A single Python file called `interpolation.py` for problem 1.
- A single Python file called `curvefit.py` for problem 2
- A PDF file containing ...

**Where to submit**:  
- PDF at [this link]()
- Code at [this link]()

## (1) Polynomial Interpolation

In class, we derived a linear system of equations for finding the coefficients of an order-$n$ polynomial that interpolates between (i.e., passes through) $n+1$ points.

![Linear system for interpolation](interpolation_system.png)

**Instructions**

You will submit a single Python file for this problem. Put your import statements and function definitions at the top of the file, and write the rest of your code underneath. The graders should be able to run your file as-is.

### (1.1) Set up the linear system of equations

Write a Python function that takes as input an array of x-values and an array of y-values, representing ordered pairs $(x_i,y_i)$, and returns (1) the system matrix, and (2) the right-hand-side vector, from slide 8 of lecture 15.
~~~python
def interpolation_system(x_values,y_values):
	# x_values and y_values should be 1-dimensional arrays of the same size.
	num = len(x_values)
	A = np.zeros((num,num))
	b = np.zeros(num)
	return A,b
~~~

### (1.2) Solve the linear system for the data provided

Download the [text file named `interpolate_these.txt`](../Resources/interpolate_these.txt) from the Resources page. Write Python code that

1. Loads the data from this text file using `numpy.loadtxt()`
2.  Assigns the columns of the text file to two separate 10-element `numpy` arrays, named, e.g., `x_data` and `y_data`
3.  Calls your function `interpolation_system` from above and stores the matrix and right-hand side.
4. Uses the `numpy` function [`numpy.linalg.solve`](https://numpy.org/doc/stable/reference/generated/numpy.linalg.solve.html) to solve the system of equations $Ax=b$, where $A$ is the matrix from `interpolation_system` and $b$ is the right-hand side from `interpolation_system`. Here, $x$, the unknown vector, contains the coefficients of our sought-for polynomial, $\{ a_0, a_1, a_2, ..., a_n \}$.

### (1.3) Assemble an interpolating function that uses the coefficients

Now that you have found coefficients $\{ a_0, a_1, a_2, ..., a_n \}$ that define the $n$-degree polynomial that interpolates between these points, write a new function that evaluates this polynomial for any $x$.

Recall that the mathematical form of this interpolating function is $$f(x; a_0, a_1, ..., a_n) = a_0 + a_1 x + a_2 x^2 + a_3 x^3 + ...$$

Your task is to write a Python function that evaluates this interpolating function at any value of $x$, for any given set of coefficients $\{ a_0, a_1, a_2, ..., a_n \}$.

~~~python
def interpolating_polynomial(x,array_a):
	# x can be any real number (NOT an array)
	# array_a will be an array containing the coefficients
	# of the order-n polynomial: a_0, a_1, a_2, etc.
	# the function should return 
	# a_0*x^0 + a_1*x^1 + a_2*x^2 + ... a_n*x^m
	return 0.0
~~~

**Note:** Note that `numpy` already contains a function that does essentially this; it's called [`numpy.polyval`](https://numpy.org/doc/stable/reference/generated/numpy.polyval.html). You may choose to implement this task as a  ['wrapper'](https://en.wikipedia.org/wiki/Wrapper_function) around `polyval`. It should be straightforward to write your own code without using `polyval`, too.

**Also Note:** This function will be generic; it won't contain any information from problem 1.1 or problem 1.2. Later, when you *call* the function, you'll provide information about what exactly the coefficients are --- and they will be the ones you found in problem 1.2.

### (1.4) Make a plot showing the data points and the interpolation
Generate a plot that shows the data points together with the interpolating curve. The following snippets of code will help you with this.

~~~python
import numpy as np
import matplotlib.pyplot as plt

# Assuming x_vals, y_vals contains the coordinates
# of the data points:
plt.scatter(x_vals,y_vals)

# Assuming you have solved 1.2 and you have an array
# of coefficients [a_0, a_1, a_2, ..., a_n] called "a" 
# found after solving the linear system in problem 1.2:

# Generate 100 x-values between the first and last coordinate
x_continuous = np.linspace(x_vals[0],x_vals[-1],100)

# Evaluate your interpolating function at all 100 points
y_continuous = interpolating_polynomial(x_continuous,a)

# Make a line plot
plt.plot(x_continuos,y_continuous,label='Interpolating func')
plt.legend()

# Save it
plt.savefig("interpolation.png")

# Show the plot
plt.show()
~~~

Your plot should look substantially similar to the one below.

![Sample figure](interpolation_sample.png)

## (2) Polynomial curve fit using least-squares

In class, we saw that the linear system for finding a best-fit curve takes the following form:

![Linear system for best fit](curvefit_system.png)

(##) Instructions 

You will submit a single Python file for this problem. Put your import statements and function definitions at the top of the file, and write the rest of your code underneath. The graders should be able to run your file as-is.


## A function for generating the linear system
Complete the activity from class, i.e., write a Python function that takes as input an array of x values, an array of y values, and an integer $m$, where $m$ is the order of the polynomial that is to be fit to the data. The function should return a matrix of size $(m+1) \times (m+1)$ and an array of size $m+1$.

~~~python
def curvefit_system(x_values,y_values,m):
	# x_values and y_values should be 1-dimensional arrays of the same size.
	A = np.zeros((m+1,m+1))
	b = np.zeros(m+1)
	return A,b
~~~

## Solve the linear system for the data provided using $m = 2$

Download the [text file](../Lecs/datapoints.txt) from Lecture 16. Write Python code that

1. Loads the data from this text file using `numpy.loadtxt()`
2.  Assigns the columns of the text file to two separate 10-element `numpy` arrays, named, e.g., `x_data` and `y_data`
3.  Calls your function `curvefit_system` from above, with `m=2`, and stores the matrix and right-hand side.
4. Uses the `numpy` function [`numpy.linalg.solve`](https://numpy.org/doc/stable/reference/generated/numpy.linalg.solve.html) to solve the system of equations $Ax=b$, where $A$ is the matrix from `curvefit_system` and $b$ is the right-hand side from `curvefit_system`. Here, $x$, the unknown vector, contains the coefficients of our sought-for polynomial, $\{ a_0, a_1, a_2, ..., a_m \}$.

## Assemble a curve-fit function that uses the coefficients

Now that you have found coefficients $\{ a_0, a_1, a_2, ..., a_m \}$ that define the $m$-degree polynomial that best fits these points, write a new function that evaluates this polynomial for any $x$.

Recall that the mathematical form of this polynomial function is $$f(x; a_0, a_1, ..., a_m) = a_0 + a_1 x + a_2 x^2 + a_3 x^3 + ...$$

Your task is to write a Python function that evaluates this function at any value of $x$, for any given set of coefficients $\{ a_0, a_1, a_2, ..., a_m \}$.

~~~python
def curvefit_polynomial(x,array_a):
	# x can be any real number (NOT an array)
	# array_a will be an array containing the coefficients
	# of the order-m polynomial: a_0, a_1, a_2, etc.
	# the function should return 
	# a_0*x^0 + a_1*x^1 + a_2*x^2 + ... a_m*x^m
	return 0.0
~~~

!!! Tip
    Note that `numpy` already contains a function that does essentially this; it's called [`numpy.polyval`](https://numpy.org/doc/stable/reference/generated/numpy.polyval.html). You may choose to implement this task as a  ['wrapper'](https://en.wikipedia.org/wiki/Wrapper_function) around `polyval`. It should be straightforward to write your own code without using `polyval`, too.

!!! Tip
     This function will be generic; it won't contain any information from problem 2.1 or problem 2.2. Later, when you *call* the function, you'll provide information about what exactly the coefficients are --- and they will be the ones you found in problem 2.2.
     
## Make a plot showing the data points with a quadratic curve fit

Generate a plot that shows the data points together with a quadratic best-fit curve. The following snippets of code will help you with this.

~~~python
import numpy as np
import matplotlib.pyplot as plt

# Assuming x_vals, y_vals contains the coordinates
# of the data points:
plt.scatter(x_vals,y_vals)

# Assuming you have solved 2.2 and you have an array
# of coefficients [a_0, a_1, a_2, ..., a_m] called "a" 
# found after solving the linear system in problem 2.2:

# Generate 100 x-values between the first and last coordinate
x_continuous = np.linspace(x_vals[0],x_vals[-1],100)

# Evaluate your interpolating function at all 100 points
y_continuous = curvefit_polynomial(x_continuous,a)

# Make a line plot
plt.plot(x_continuos,y_continuous,label='Best Fit')
plt.legend()

# Save it
plt.savefig("bestfit.png")

# Show the plot
plt.show()
~~~

Your plot should look substantially similar to the one below.

![Sample figure](curvefit_sample.png)



## (1) Golden Section Search in Python

**What to turn in:** Code for (1.1), (1.2) and (1.3), PDF for (1.2) and (1.3)

### (1.1) Write a program

Write a program that uses the Golden Section Search algorithm to find either a maximum or a minimum of the function $f(x)$. Your function should accept, as one of its arguments, the string `max` or `min`, and should correspondingly try to maximize or minimize $f(x)$.

Your program should accept the following arguments:
- a function, which is to be optimized
- Two real numbers `a` and `b`, corresponding to the left-ward and right-ward edges of the region which is to be searched for an optimum,
- a parameter `tol`, which in practice will be a small number such as `1e-6` or similar.
- a string, which --- if the program is used correctly --- should either be `max` or `min`.

### (1.2) Use your program to solve optimization problems

Test your program by finding two different minima and two different maxima of the following function. Illustrate that you have done this correctly by generating a plot of the function together with points indicating the minima and maxima that you find.

~~~python
import numpy as np

def f1(x): return np.exp(-0.5*x)*np.sin(x))
~~~

Also test your program by finding all the turning point of the following function. Illustrate that you have done this correctly by generating a plot of the function together with points indicating the extrema you have found.

~~~python
import numpy as np

def f2(x): return 2*(x**2)*(x-np.exp(0.1*x))**2
~~~

### (1.3) Document the rate at which the interval size decreases

For either one of the examples above, generate a plot of $h$, which is the interval size, against the step number on a log-log scale. Do this with as low a value of the `tolerance` parameter as you are able to use, i.e., try to get $h$ down to as small a number as you can.

## (2) Constraints

**What to turn in:** PDF only  

While solving a 3-dimensional optimization problem involvingthe minimization of the function $$f(x,y,z) = ...$$ you are required to look for solutions {x,y,z} that exist on the surface of a sphere centered at the point $(1,1,0)$ having radius $2$. Assuming the function $f(x,y,z)$ is some known function of three variables, write down the function that you would minimize instead of $f$ in order to meet the constraint.

## (3) Naive n-dimensional optimization

**What to turn in:** Code for (3.1) and (3.2), PDF for (3.2)

### (3.1) Write a function that minimizes 2-dimensional functions

Write a function that implements naive n-dimensional optimization of a given function $f$. You should assume throughout this problem that $n=2$. As stated during the in-class activity, your function must take as input: 
- the function $f$ to be minimized
- A guess consisting of a point [x,y]
- A set of 2 direction vectors, each of size 2x1
- A tolerance parameter that terminates the search when $$|| x_{n+1}-x_{n} ||$$ is lower than a certain threshold.

Your function should return a history of all of the pairs $(x_i,y_i)$ from $i=1$ to $i=m$, where $m$ is the total number of steps that your algorithm took when looking for a minimum. It is up to you how to format the output of your function. For example, you can return an $m$-elements long list of 2x1 `numpy` arrays, or you can return a two-dimensional `numpy` array of size 2xm or mx2.

### (3.2) Apply your function

For each of the following sub-tasks, you must produce a plot to submit as part of your PDF and you must also turn in your code. For tasks 3-6, when you illustrate your result, make **two** plots: one should show a zoomed-in picture where the action is happening, and one should show a bigger-picture look at the function's behavior.


1. Use your function to solve the optimization problem from HW 9, using the same direction vectors and initial guess. Use a relatively high tolerance, such as `1e-4`.
2. Use your function to solve the optimization problem from HW 9, using the same initial guess but different direction vectors. You may choose any two directions.
3. Use your function to optimize the noisy function included below, starting from the point $(0,0)$ using the directions `[0.5,1]` and `[0,1]`. When you illustrate your result, make **two** plots: one should show a zoomed-in picture where the action is happening, and one should show a bigger-picture look at the function's behavior. For this and the subsequent tasks, use the following parameters when setting up the noisy function: `make_noisy_function(n=2, noise_amp=3.1, sigma=12)`
4. For the same starting point as above, choose a different set of direction vectors than above, and show your results.
5. Choose a different starting point and direction vectors of your own choice. Show your results.
6. Find the minimum of the noisy function that lives on a circle of radius 3 centered at the origin.

#### Constructing the noisy function
For tasks 3-6 above, you will make use of a custom function, which we have been calling the 'noisy function'. This function is an artificially-constructed one that has some elements of periodicity and some elements of randomness; these combine to make a less-straightforward optimization problem than the ones you've been looking at so far. You **do not have to write this function**; it is provided below. 

~~~python
import numpy as np
from scipy.ndimage import gaussian_filter
from scipy.interpolate import RegularGridInterpolator
import matplotlib.pyplot as plt

def make_noisy_function(n=2, noise_amp=1.0, sigma=10, 
                        xlim=(-10,10), ylim=(-10,10), 
                        resolution=500):
    # This function takes as argument some optional parameters
    # and returns a Python function. So if you run `f = make_noisy_function()`
    # then f will become a function of two variables, i.e., `f(x,y)`.
    
    # Base grid
    x = np.linspace(*xlim, resolution)
    y = np.linspace(*ylim, resolution)
    X, Y = np.meshgrid(x, y)

    # Base function
    Z = np.sin(n*X) + np.sin(n*Y)

    # Smooth noise
    noise = np.random.randn(*Z.shape)
    smooth_noise = gaussian_filter(noise, sigma=sigma)
    smooth_noise /= np.max(np.abs(smooth_noise))  # normalize to [-1,1]

    # Add noise
    Z_noisy = Z + noise_amp * smooth_noise

    # Interpolator turns it into a callable function f(x, y)
    f_interp = RegularGridInterpolator((x, y), Z_noisy, bounds_error=False, fill_value=None)

    def f(x, y=None):
        if y is None:
            # function has been passed with one argument.
            # Treat that argument as a vector [x,y]
            pts = x
        else:
            # function has been passed with two arguments.
            # Treat them as x and y.
            x = np.atleast_1d(x)
            y = np.atleast_1d(y)
            pts = np.column_stack([x, y])
        vals = f_interp(pts)
        if vals.size == 1:
            return vals.item()
        else:
            return vals

    return f

# How to use the above 'constructor function':
test_function = make_noisy_function(n=5, noise_amp=0.1, sigma=10)
~~~

The code above creates a function called `test_function`, which you can now make use of. This is the function to be minimized in tasks 3-6.

#### Sample results

The required plots can be made using code such as that included below. You are welcome to adapt this code for your work. This won't work for you immediately because you have to write `naive_nd_optimize` yourself.

~~~python
f2 = make_noisy_function(n=2, noise_amp=3.1, sigma=12)
hist1 = naive_nd_optimize(f2,[0,0],[[1,0],[0,1]],40)

# Create a grid of points
x = np.linspace(-5, 5, 300)
y = np.linspace(-5, 5, 300)
X, Y = np.meshgrid(x, y)

# Evaluate your noisy function over the above grid.
# Here, the noisy function was named `f2`.
Z = f2(X.ravel(), Y.ravel()).reshape(X.shape)

figure1, (axes1, axes2) = plt.subplots(1,2,figsize=(10,5))

figure1.suptitle('HW 10, Problem 3')

contour1 = axes1.contourf(X, Y, Z, levels=40)
plt.colorbar(contour1, label='f(x, y)')
axes1.set_xlim(left=-2,right=1)
axes1.set_ylim(bottom=-2,top=1)
axes1.plot(hist1[:,0],hist1[:,1],color='red')
axes1.set_title('Zoomed-in view')


contour2 = axes2.contourf(X, Y, Z, levels=40)
plt.colorbar(contour2, label='f(x, y)')
axes2.plot(hist1[:,0],hist1[:,1],color='red')
axes2.set_title('Zoomed-out view')

plt.show()
~~~

![Sample](optimfig1.png)

{% include mathjax.html %}
